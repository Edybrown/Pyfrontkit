# Copyright (c) 2025 Eduardo Antonio Ferrera Rodr√≠guez
# SPDX-License-Identifier: MIT


from typing import Literal, Tuple, Optional
from lxml import html, etree
from .style_manager import StyleManager, CSSProcessor
from .css_register import CSSRegistry
from .block import Block
from .helpers.fs import _write_file


class HtmlDoc:
    def __init__(self, title="Untitled Document", path=".", **head_attrs):
        self.title = title
        self.path = path.strip()
        if not self.path.endswith("/"):
            self.path += "/"

        self.html_file = self.path + "index.html"
        self.css_file = self.path + "style.css"

        # Optional head attributes
        self.head_attrs = head_attrs

        # ‚úÖ Body scripts (for doc.script())
        self._body_scripts = []

        # Optional links (only if passed)
        self.links = head_attrs.get("links", [])

        # üåü CORRECCI√ìN CR√çTICA: Inicializar atributos faltantes para evitar AttributeError
        self.inline_style = head_attrs.get("inline_style")
        self.head_scripts = head_attrs.get("head_scripts", [])

        # Base HTML and CSS templates
        self._html_base = self._generate_base_html()
        self._css_base = self._generate_base_css()

    def _generate_head(self):
        lines = ["<meta charset='UTF-8'>"]
        lines.append(f"<title>{self.title}</title>")
        lines.append("<link rel='stylesheet' href='style.css'>")

        # Optional <link> tags
        for link in self.links:
            lines.append(f"<link rel='stylesheet' href='{link}'>")

        # Add optional inline style
        if self.inline_style:
            lines.append("<style>")
            lines.append(self.inline_style)
            lines.append("</style>")

        # Add external scripts
        for src in self.head_scripts:
            lines.append(f"<script src='{src}'></script>")

        return lines

    def _generate_base_html(self):
        # Uso join para un mejor formato
        head_content = "\n\t".join(self._generate_head())
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    {head_content}
</head>
<body>
{{body_content}}
{{body_scripts}}
</body>
</html>
"""

    def _generate_base_css(self):
        return """/* Stylesheet generated by PyFrontKit */
body {
    margin: 0;
    padding: 0;
}
h1, h2, h3, h4, h5, h6, p, ul, ol, li {
    margin: 0;
    padding: 0;
    line-height: 1;
}
"""

    # ------------------------------
    # Body rendering
    # ------------------------------
    def render_body(self):
        """
        Renders blocks that have no parent, preserving creation order.
        """
        html = ""
        for block in Block._registry:
            if block._parent is None:
                html += block.render(indent=2)
        return html

    # ------------------------------
    # ‚úÖ New simple method
    # ------------------------------
    def script(self, js_code):
        """
        Adds raw JavaScript that will be printed
        at the end of the <body>.
        """
        if js_code:
            self._body_scripts.append(js_code)
        return self

    # ------------------------------
    # Document creation
    # ------------------------------
    def create_document(self, output: Literal["file", "raw", "both"] = "file") -> Optional[Tuple[str, str]]:
        """
        Builds the final HTML and CSS documents and exports them according to the
        specified output mode.

        This method is responsible for:
        - Registering CSS styles from all registered blocks.
        - Rendering the document body and inline scripts.
        - Generating the final HTML and CSS outputs.

        Output modes:
            - "file": Writes the generated HTML and CSS to disk (default behavior).
            - "raw": Returns the generated HTML and CSS as raw strings.
            - "both": Writes the files to disk and also returns the raw outputs.

        Args:
            output (Literal["file", "raw", "both"], optional):
                Determines how the generated document should be exported.
                Defaults to "file".

        Returns:
            Optional[Tuple[str, str]]:
                - ("raw"): Returns a tuple (html, css).
                - ("both"): Returns a tuple (html, css).
                - ("file"): Returns None.

        Raises:
            Exception:
                Propagates any exception raised during file creation or style
                application.
        """

        for block in Block._registry:
            CSSRegistry.register_block(block)

        body_content = self.render_body()
        body_scripts = "\n".join(
            f"<script>\n{code}\n</script>" for code in self._body_scripts
        )

        html_final = (
            self._html_base
            .replace("{body_content}", body_content)
            .replace("{body_scripts}", body_scripts)
        )
        css_final = self._css_base + "\n" + CSSRegistry.generate_css()

        if output in ("raw", "both"):
            # return utf-8 strings
            return {
                "html": html_final,
                "css": css_final
            }

        if output in ("file", "both"):
            _write_file(self.html_file, html_final, "HTML")
            _write_file(self.css_file, css_final, "CSS")
            StyleManager(css_file=self.css_file).apply_styles()
        return None

    def bundle_document(self, output: Literal["file", "raw", "both"] = "file", filename: str = "bundle.html", ) -> Optional[str]:
        """
        Bundles HTML and CSS into a single self-contained HTML document by
        injecting the CSS into a <style> tag inside the <head>.

        This method acts as a post-processor/exporter and does not render
        blocks or generate styles by itself.

        Args:
            html_source (str):
                The final rendered HTML source.
            css_source (str):
                The final generated CSS source.
            output (Literal["file", "raw", "both"], optional):
                Determines how the bundled document is exported.
            filename (str, optional):
                Output filename when writing to disk.

        Returns:
            Optional[str]:
                - ("raw" | "both"): The bundled HTML document.
                - ("file"): None.
        """

        for block in Block._registry:
            CSSRegistry.register_block(block)

        body_content = self.render_body()
        body_scripts = "\n".join(
            f"<script>\n{code}\n</script>" for code in self._body_scripts
        )

        html_final = (
            self._html_base
            .replace("{body_content}", body_content)
            .replace("{body_scripts}", body_scripts)
        )
        css_final = self._css_base + "\n" + CSSRegistry.generate_css()
        css_final = CSSProcessor.apply_rules(css_text=css_final)

        # remove the link style.css from head and replace with <style> tag
        tree = html.fromstring(html_final)
        head = tree.find("head")

        for link in head.findall("link"):
            if link.get("rel") == "stylesheet" and link.get("href") == "style.css":
                head.remove(link)

        style_element = etree.Element("style")
        style_element.text = css_final

        head.append(style_element)
        bundled_html = etree.tostring(
            tree, pretty_print=True, method="html", encoding="unicode"
        )

        if output in ("raw", "both"):
            return bundled_html

        if output == "file":
            _write_file(filename, bundled_html, "Bundled HTML")

        return None

    # ------------------------------
    # Body align system
    # ------------------------------
    def align(self, orientation=None, gap=None, padding=None, grid_column=None):
        """
        Apply styles to the document's body, similar to Block.align,
        but always targets the 'body' selector.
        """
        if orientation is None:
            print("The method align() requires the 'orientation' parameter")
            return self

        if orientation not in ("column", "row", "grid"):
            print("align(): invalid orientation. Use 'column', 'row', or 'grid'")
            return self

        if orientation == "grid" and not grid_column:
            print("align(): 'grid_column' is required when orientation='grid'")
            return self

        selector = "body"

        templates = {
            "column": '''
    display: flex;
    flex-direction: column;
    width: 100%;
    {gap}
    {padding}
    ''',
            "row": '''
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    {padding}
    {gap}
    ''',
            "grid": '''
    display: grid;
    grid-template-columns: repeat({grid_column}, 1fr);
    {gap}
    {padding}
    '''
        }

        gap_text = f"gap: {gap};" if gap else ""
        padding_text = f"padding: {padding};" if padding else ""

        template = templates[orientation]
        css_text = template.format(
            gap=gap_text,
            padding=padding_text,
            grid_column=grid_column if grid_column else "1"
        )

        from .style_manager import CSS_RULES_STYLE
        CSS_RULES_STYLE.append({selector: {"css": css_text}})

        return self
